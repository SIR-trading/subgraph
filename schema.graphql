type Token @entity(immutable: false) {
  id: Bytes! # Token contract address
  symbol: String
  decimals: Int!
  isCollateral: Boolean!
  isDebt: Boolean!
  vaultCount: Int! # Number of vaults using this token (as collateral or debt)
}

type TokenPairVolatility @entity(immutable: false) {
  id: Bytes!                       # sorted(token0, token1) concatenated
  token0: Token! @link             # smaller address (sorted)
  token1: Token! @link             # larger address (sorted)
  ewmaN: BigDecimal!               # EWMA numerator state
  ewmaD: BigDecimal!               # EWMA denominator state
  lastPrice: BigInt!               # Oracle tick in Q21.42 format (always token0/token1 direction)
  lastTimestamp: BigInt!           # last update timestamp
  volatilityAnnual: BigDecimal!    # computed annualized volatility
  vaultCount: Int!                 # vaults using this pair
}

type Vault @entity(immutable: false) {
  id: Bytes!
  exists: Boolean!
  collateralToken: Token! @link
  debtToken: Token! @link
  leverageTier: Int!
  totalValue: BigInt!
  totalValueUsd: BigDecimal!
  lockedLiquidity: BigInt!
  teaSupply: BigInt!
  reserveApes: BigInt!
  reserveLPers: BigInt!
  tax: BigInt!
  rate: BigInt!
  ape: Token! @link
  feesIds: [Bytes!]!
  volatility: TokenPairVolatility @link  # 30-day realized volatility for this token pair
}

type UsdRefreshState @entity {
  id: Bytes! # "usd-refresh" singleton
  nextVaultIdToRefresh: BigInt! # Next vault ID number in rotation (1, 2, 3...)
  highestVaultId: BigInt! # Highest vault ID created, for wrap-around
}

type Fee @entity(immutable: false) {
  id: Bytes!
  vaultId: Bytes!
  timestamp: BigInt!
  lpApy: BigDecimal!
}

type TeaPosition @entity(immutable: false) {
  id: Bytes!
  vault: Vault! @link
  user: Bytes!
  balance: BigInt!
  collateralTotal: BigInt!
  dollarTotal: BigDecimal!
  debtTokenTotal: BigInt!
  lockEnd: BigInt! # Timestamp when TEA becomes unlocked (0 = no lock)
  createdAt: BigInt! # Block timestamp of first mint (resets after full burn)
}

type ApePosition @entity(immutable: false) {
  id: Bytes!
  vault: Vault! @link
  user: Bytes!
  balance: BigInt!
  collateralTotal: BigInt!
  dollarTotal: BigDecimal!
  debtTokenTotal: BigInt!
  createdAt: BigInt! # Block timestamp of first mint (resets after full burn)
}

type ApePositionClosed @entity(immutable: true) {
  id: Bytes!
  vault: Vault! @link
  user: Bytes!
  collateralDeposited: BigInt!
  dollarDeposited: BigDecimal!
  collateralWithdrawn: BigInt!
  dollarWithdrawn: BigDecimal!
  timestamp: BigInt!
}

type TeaPositionClosed @entity(immutable: true) {
  id: Bytes!
  vault: Vault! @link
  user: Bytes!
  collateralDeposited: BigInt!
  dollarDeposited: BigDecimal!
  collateralWithdrawn: BigInt!
  dollarWithdrawn: BigDecimal!
  timestamp: BigInt!
}

type Dividend @entity(immutable: true) {
  id: Bytes!
  ethAmount: BigInt!
  sirEthPrice: BigDecimal
  stakedAmount: BigInt!
  timestamp: BigInt!
}

type Auction @entity(immutable: false) {
  id: Bytes!
  token: Token! @link
  amount: BigInt!
  highestBid: BigInt!
  highestBidder: Bytes!
  startTime: BigInt!
  isClaimed: Boolean!
  participants: [AuctionsParticipant!] @derivedFrom(field: "auctionId")
}

type AuctionsParticipant @entity(immutable: false) {
  id: Bytes!
  auctionId: Auction! @link
  user: Bytes!
  bid: BigInt!
}

type AuctionStats @entity {
  id: Bytes! # singleton "stats"
  totalAuctions: BigInt! # total auctions ever started
}

type CurrentAuction @entity {
  id: Bytes! # token address
  auction: Auction! @link # reference to the current auction for this token
}
